/*
===========================================================
Problem :- Remove Element
Difficulty :- Easy
===========================================================

Description :-
  Given an integer array nums and an integer val, remove all occurrences of val 
  in-place. The order of the elements may be changed. Then return the number of 
  elements in nums which are not equal to val.
  You must modify the array nums in-place so that the first k elements of nums 
  contain the elements that are not equal to val. It does not matter what you 
  leave beyond the returned k.

Example 1 :-
  Input: nums = [3,2,2,3], val = 3
  Output: 2, nums = [2,2,_,_]

Example 2 :-
  Input: nums = [0,1,2,2,3,0,4,2], val = 2
  Output: 5, nums = [0,1,4,0,3,_,_,_]

Constraints :-
  1) 0 <= nums.length <= 100
  2) 0 <= nums[i] <= 50
  3) 0 <= val <= 100

Approach :-
  1) Use a pointer (count) to track the position of valid elements.
  2) Traverse the array:
     1. If nums[i] != val, place it at nums[count] and increment count.
     2. Skip elements equal to val.
  3) Return count as the number of valid elements.

Time Complexity: O(n)
Space Complexity: O(1)
===========================================================
*/

Solution :- 
  public class RemoveElement {
      public int removeElement(int[] nums, int val) {
          int count = 0; 
          for (int i = 0; i < nums.length; i++) {
              if (nums[i] != val) {
                  nums[count] = nums[i];
                  count++;
              }
          }
          return count; 
      }
  }
