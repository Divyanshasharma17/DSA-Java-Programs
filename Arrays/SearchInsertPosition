/*
===========================================================
Problem :- Search Insert Position
Difficulty :- Easy
===========================================================

Description :-
  Given a sorted array of distinct integers and a target value, 
  return the index if the target is found. If not, return the 
  index where it would be if it were inserted in order.
  The algorithm must run in O(log n) time complexity.

Example :-
  Input: nums = [1,3,5,6], target = 2
  Output: 1
  Input: nums = [1,3,5,6], target = 7
  Output: 4

Approach :-
  1) Use Binary Search to achieve O(log n) runtime.
  2) Initialize pointers `start = 0` and `end = nums.length - 1`.
  3) While start <= end:
    Compute mid = (start + end) / 2.
    If nums[mid] == target → return mid.
    If nums[mid] > target → search left half.
    Otherwise → search right half.
  4)target not found, return `start` as the insertion index.

Time Complexity :- O(log n)
Space Complexity :- O(1)
===========================================================
*/

Solution :-
  import java.util.*;
  public class SearchInsertPosition {
      public int searchInsert(int[] nums, int target) {
          int start = 0;
          int end = nums.length - 1;
          while (start <= end) {
              int mid = (start + end) / 2;
              if (nums[mid] == target) {
                  return mid; // target found
              } else if (nums[mid] > target) {
                  end = mid - 1; 
              } else {
                  start = mid + 1; 
              }
          }
          return start; 
      }
  }
